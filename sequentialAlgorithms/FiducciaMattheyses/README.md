
## Fiduccia-Mattheyses Algorithm for Graph Partitioning  

<p align="justify">
  The Fiduccia-Mattheyses algorithm is a well-known iterative bi-partitioning algorithm used for graph partitioning. It aims to partition a given graph into two subgraphs while minimizing the edge-cut, which represents the number of edges crossing the partition boundary.
</p>
<p align="justify">
Begin with an initial partition of the graph vertices into two sets, often randomly or based on some heuristic.  
Iterate through the vertices and consider moving each vertex from its current partition to the other partition if it improves the overall edge-cut.  
Compute the gain in edge-cut for moving each vertex and select the vertex that maximizes this gain.  
Move the selected vertex to the other partition if the gain is positive (or zero if tie-breaking rules apply).  
Repeat this process until no further improvements can be made or a termination condition is met.  
Terminate the algorithm when no further improvement is possible, typically after a predefined number of iterations or when a certain threshold for improvement is reached.  
</p>
<p align="justify">
The gain of a vertex represents the reduction of the cut generated by the transfer
of this vertex to the other part of the bisection. Formally, the gain g(v) of vertex v
is equal to the difference between the external cost and the internal cost of the vertex.
According to equation D(vi) = E(vi) − I(vi), g(v) = D(v).
Consider two vertices each belonging to a different part of the bisection P =
(V1, V2), v1 ∈ V1 and v2 ∈ V2. The gain, denoted by g, resulting from the exchange of
v1 and v2 is:
g(v1, v2) = D(v1) + D(v2) − 2w(v1, v2).
For each vertex vi ∈ Vi, the algorithm calculates the difference between the external
cost and the internal cost of vi, that is D(vi). The values D(vi) are distributed in two
sets D1 and D2, according to the part to which vi belongs.
To maintain the gain of the updated vertices, we use the data structure of an `unordered_map`.
The gain initialization for each vertex has a complexity of O(|E|). Similarly, because
the vertices gain update is constant, each pass of the Kernighan-Lin algorithm is O(|E|).
Thus, the general complexity of the algorithm is linear as compared to the size of E,
which is a great improvement when compared to the Kernighan-Lin algorithm, which
was O(|E|2 log |E|).
</p>


## Supported Platforms

The programs in this repository can be run on Linux, Windows, and macOS. Ensure you have a C++ compiler installed on your system. If you're using Windows, consider using MinGW or Visual Studio. On macOS and Linux, the default system compiler should suffice.

## Getting Started

To use the programs in this repository, follow these steps:

### Cloning the Repository

1. Clone this repository to your local machine:

   ```bash
   git clone https://github.com/Eugenio8mola/GraphPartitioning/sequentialAlgorithms/FiducciaMattheyses.git

2. Navigate to the project directory:

   ```bash
   cd GraphPartitioning/sequentialAlgorithms/FiducciaMattheyses
   ```

### Compiling and Running

1. Compile the program using your preferred C++ compiler:

   ```bash
   g++ -o fidmat main.cpp
   ```

2. Run the program:

   ```bash
   ./fidmat numberOfNode maxWeight number_partitions
   ```

   Replace `numberOfNode` with the desired number of nodes that should be used for graph generation, `maxWeight` with the maximum node weight that should be used for graph generation, and `number_partitions` with the desired number of partitions that should be applied.

### Functions

## `graph`

In the class of the graph we have a constructor that receives two parameters:
1. `n` number of nodes
2. `max_w` maximum weight for nodes

This constructor randomly generates a completed graph approximately.

## `saveAdjacencyList`

This function receives three parameters and saves the graph in the format of the "Adjacency List" in the file. 
1. `g` the graph
2. `n` number of nodes
3. `filename` is the name of the file

## `readAdjacencyList`

This function receives two parameters and reads the graph from the file and puts it in a vector of vectors.
1. `filename` is the name of the file
2. `g` An object from the class of graph

## `get_vertex_weight`

This function receives the number of one node and then returns the weight of the node.
`vertex` is the number of one node

## `getAllWeigt`

This function returns the vector of the weights.

## `numNode`

This function returns the number of nodes.

## `get_weight_partition`

This function receives a partition and then returns the summation of all node weights.

## `get_max_weight`

This function returns the maximum weight in the vector of weights.

## `get_edge_weight`

This function receives a pair `edge` including two nodes and then returns the weight of edges:
if there exists an edge it returns the weight of the edge, otherwise it returns 0.

## `get_adjacent_vertices`

This function receives the number of a node and then returns all nodes that are adjacent to it.
The output of the function is a `set<int>`.

## `make_new_graph`

After splitting the graph in each iteration we call this function and pass the partitions `vec` to this function to generate two new graphs.

## `calculateIED`

The `calculateIED` function computes the Internal Edge Density (IED) and External Edge Density (EED) for each vertex in two partitions of a graph. Internal Edge Density represents the sum of edge weights between vertices within the same partition, while External Edge Density represents the sum of edge weights between vertices in different partitions. Parameters:  
`g`: Reference to the graph object on which calculations are performed.  
`p1`: Vector representing the vertices in the first partition.  
`p2`: Vector representing the vertices in the second partition.  
`Internal`: Reference to an unordered map where the Internal Edge Density values for each vertex will be stored.  
`External`: Reference to an unordered map where the External Edge Density values for each vertex will be stored.  
`D`: Reference to an unordered map where the Density difference values (EED - IED) for each vertex will be stored.  
1. For each vertex in partition 1 (`p1`), iterate through its adjacent vertices (`F`).  
2. For each adjacent vertex, check if it belongs to partition 1 or partition 2:  
      If it belongs to partition 1, increment the Internal Edge Density (i) by the edge weight.  
      If it belongs to partition 2, increment the External Edge Density (e) by the edge weight.  
3. Store the `Internal` (i) and `External` (e) Edge Density values for the vertex in the respective unordered maps.

Repeat steps 1-3 for vertices in partition 2 (`p2`).  

Calculate the Density difference (EED - IED) for each vertex and store it in the unordered map `D`.  



## `calculateGain`

The `calculateGain` function computes the gain for each possible movement of vertices between two partitions in a graph. The gain represents the change in the density difference (EED - IED) if a vertex is moved from one partition to another. This gain is calculated by considering the change in density difference for all possible vertex movements between the two partitions. Parameters:  
`g`: Reference to the graph object on which calculations are performed.  
`p1`: Vector representing the vertices in the first partition.  
`p2`: Vector representing the vertices in the second partition.  
`D`: Reference to an unordered map containing the density difference values (EED - IED) for each vertex.  
`gain`: Reference to an unordered map where the gain for each possible movement of vertices between partitions will be stored. The key is a pair of vertices (one from each partition), and the value is the gain associated with moving these vertices.  
Iterate through each vertex in partition 1 (`p1`).  
For each vertex in partition 1, iterate through each vertex in partition 2 (`p2`).  
Calculate the gain for moving the current pair of vertices from different partitions.  
`Gain` is computed as the sum of the density differences of the vertices in their current partitions minus twice the edge weight between them.  
Store the gain value for each pair of vertices in the unordered map `gain`.  

## `calculateCutSize`

The `calculateCutSize` function computes the cut size of a partition in a graph. The cut size represents the total weight of edges that connect vertices in the partition to vertices outside the partition. Parameters:  
`p1`: Vector representing the vertices in the partition for which the cut size is calculated.  
`External`: Reference to an unordered map containing the External Edge Density values for each vertex. This map represents the sum of edge weights between vertices in the partition and vertices outside the partition.  
Return Value:  
+  `t`: Integer representing the cut size of the partition.


## `GGGP`

This function implements "the Greedy Graph Growing Partitioning algorithm (GGGP)". The `purpose` of the `GGGP` function is to partition a given graph into subgraphs such that each subgraph satisfies a certain weight constraint. It uses a greedy algorithm to iteratively select vertices with the highest gain until the weight constraint is met, then recursively partitions the resulting subgraphs.  
The function `initializes` a set `E` containing a single vertex with the maximum weight in the graph.  
It also initializes a set `F` containing adjacent vertices to the vertex `v0`.  
For each vertex `v` in set `F`, it calculates the gain using the `calculate_gain` function and stores it in a `map gain`.  
It iteratively selects vertices with the highest gain from set `F` until the total weight of vertices in set `E` reaches half of the total weight of all vertices in the graph.  
The vertex with the highest gain is selected by iterating through set `F` and finding the vertex with the maximum gain. In the case of ties, the vertex with the minimum weight is chosen.  
Selected vertices are moved from set `F` to set `E`, and their weights are added to the total weight of vertices in set `E`.  
The adjacent vertices of the selected vertices that are not already in sets `E` or `F` are added to set `F`.  
After the greedy partitioning process, the function creates two partitions based on sets `E` and `F`.  
It then recursively calls itself (GGGP) on each partition if the partition size is greater than or equal to 2 and np (partitioning depth) is greater than 1.  

It receives two parameters:   
1. `g` the input graph    
2. `np` is the number of partitions to perform
   
## `isPowerOf2`

This function has one input and gets the `np` as the number of partitions then checks whether it is a multiple of a power of 2 or not.

## `DFS`

The DFS function is a recursive function that performs depth-first search traversal starting from a given vertex in the graph. This function has three parameters and is used in the function of `isContiguous` to check that the graph is contiguous or not:

1. `graph`: This parameter represents the adjacency matrix of the graph. It's a 2D vector where graph[i][j] is 1 if there is an edge from vertex i to vertex j, and 0 otherwise.
2. `visited`: This parameter is a reference to a boolean vector indicating whether each vertex has been visited during the DFS traversal. Initially, all elements of this vector are set to false to indicate that no vertices have been visited.
3. `vertex`: This parameter represents the current vertex being visited during the DFS traversal. Initially, this will be the starting vertex of the traversal.

## `isContiguous`

This function gets the `graph` as an input and then uses depth-first search (DFS) algorithms to traverse the graph and check if all vertices are reachable from any arbitrary starting vertex. If all vertices are reachable, then the graph is contiguous and returns `true` otherwise it returns `false`.

## `print`

This function receives the grap `g` as an input and prints it in the output.

## `print_partitions`

After splitting the graph in each iteration we will have two partitions `result`, so we pass them to this function and it prints them in the output.
