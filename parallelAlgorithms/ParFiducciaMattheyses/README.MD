
## Fiduccia-Mattheyses Algorithm for Graph Partitioning  

<p align="justify">
  The Fiduccia-Mattheyses algorithm is a well-known iterative bi-partitioning algorithm used for graph partitioning. It aims to partition a given graph into two subgraphs while minimizing the edge-cut, which represents the number of edges crossing the partition boundary.
</p>
<p align="justify">
Begin with an initial partition of the graph vertices into two sets, often randomly or based on some heuristic.  
Iterate through the vertices and consider moving each vertex from its current partition to the other partition if it improves the overall edge-cut.  
Compute the gain in edge-cut for moving each vertex and select the vertex that maximizes this gain.  
Move the selected vertex to the other partition if the gain is positive (or zero if tie-breaking rules apply).  
Repeat this process until no further improvements can be made or a termination condition is met.  
Terminate the algorithm when no further improvement is possible, typically after a predefined number of iterations or when a certain threshold for improvement is reached.  
</p>
<p align="justify">
The gain of a vertex represents the reduction of the cut generated by the transfer
of this vertex to the other part of the bisection. Formally, the gain g(v) of vertex v
is equal to the difference between the external cost and the internal cost of the vertex.
According to equation D(vi) = E(vi) − I(vi), g(v) = D(v).
Consider two vertices each belonging to a different part of the bisection P =
(V1, V2), v1 ∈ V1 and v2 ∈ V2. The gain, denoted by g, resulting from the exchange of
v1 and v2 is:
g(v1, v2) = D(v1) + D(v2) − 2w(v1, v2).
For each vertex vi ∈ Vi, the algorithm calculates the difference between the external
cost and the internal cost of vi, that is D(vi). The values D(vi) are distributed in two
sets D1 and D2, according to the part to which vi belongs.
To maintain the gain of the updated vertices, we use the data structure of an `unordered_map`.
The gain initialization for each vertex has a complexity of O(|E|). Similarly, because
the vertices gain update is constant, each pass of the Kernighan-Lin algorithm is O(|E|).
Thus, the general complexity of the algorithm is linear as compared to the size of E,
which is a great improvement when compared to the Kernighan-Lin algorithm, which
was O(|E|2 log |E|).
</p>


### Multithreading Section

The multithreading approach aims to improve performance by utilizing multiple CPU cores for parallel computation, thereby potentially reducing the overall execution time. We initialize two threads (Th1 and Th2) to concurrently execute the fiducciaMattheyses function on two subgraphs (g1 and g2):

`step1`: Thread Creation:

Two thread objects (Th1 and Th2) are declared.
Each thread is responsible for executing the fiducciaMattheyses function on a separate subgraph.

`step2`: Conditional Thread Launch:

The decision to launch a thread is based on the size of the subgraph partitions (partitions[0] and partitions[1]).
If a partition contains at least two vertices (partitions[i].size() >= 2), a corresponding thread is created to process the subgraph.

`step3`: Thread Execution:

The fiducciaMattheyses function is called recursively on the subgraph using the std::thread constructor.
Each thread is assigned a subgraph (g1 or g2) and the same partitioning depth (`np` as a number of partitions in each iteration).

`step4`: Thread Synchronization:

After launching both threads, the main thread waits for their completion before proceeding further.
The join() method is called on each thread object (Th1.join() and Th2.join()), which blocks the main thread until the associated thread finishes execution.




## Supported Platforms

The programs in this repository can be run on Linux, Windows, and macOS. Ensure you have a C++ compiler installed on your system. If you're using Windows, consider using MinGW or Visual Studio. On macOS and Linux, the default system compiler should suffice.

## Getting Started

To use the programs in this repository, follow these steps:

### Cloning the Repository

1. Clone this repository to your local machine:

   ```bash
   git clone https://github.com/Eugenio8mola/GraphPartitioning/parallelAlgorithms/ParFiducciaMattheyses.git

2. Navigate to the project directory:

   ```bash
   cd GraphPartitioning/parallelAlgorithms/ParFiducciaMattheyses
   ```

### Compiling and Running

1. Compile the program using your preferred C++ compiler:

   ```bash
   g++ -o parfidmat main.cpp
   ```

2. Run the program:

   ```bash
   ./parfidmat numberOfNode maxWeight number_partitions
   ```

   Replace `numberOfNode` with the desired number of nodes that should be used for graph generation, `maxWeight` with the maximum node weight that should be used for graph generation, and `number_partitions` with the desired number of partitions that should be applied.

### Functions

## `graph`

In the class of the graph we have a constructor that receives two parameters:
1. `n` number of nodes
2. `max_w` maximum weight for nodes

This constructor randomly generates a completed graph approximately.

## `saveAdjacencyList`

This function receives three parameters and saves the graph in the format of the "Adjacency List" in the file. 
1. `g` the graph
2. `n` number of nodes
3. `filename` is the name of the file

## `readAdjacencyList`

This function receives two parameters and reads the graph from the file and puts it in a vector of vectors.
1. `filename` is the name of the file
2. `g` An object from the class of graph

## `get_vertex_weight`

This function receives the number of one node and then returns the weight of the node.
`vertex` is the number of one node

## `getAllWeigt`

This function returns the vector of the weights.

## `numNode`

This function returns the number of nodes.

## `get_weight_partition`

This function receives a partition and then returns the summation of all node weights.

## `get_max_weight`

This function returns the maximum weight in the vector of weights.

## `get_edge_weight`

This function receives a pair `edge` including two nodes and then returns the weight of edges:
if there exists an edge it returns the weight of the edge, otherwise it returns 0.

## `get_adjacent_vertices`

This function receives the number of a node and then returns all nodes that are adjacent to it.
The output of the function is a `set<int>`.

## `make_new_graph`

After splitting the graph in each iteration we call this function and pass the partitions `vec` to this function to generate two new graphs.

## `calculateIED`

The `calculateIED` function computes the Internal Edge Density (IED) and External Edge Density (EED) for each vertex in two partitions of a graph. Internal Edge Density represents the sum of edge weights between vertices within the same partition, while External Edge Density represents the sum of edge weights between vertices in different partitions. Parameters:  
`g`: Reference to the graph object on which calculations are performed.  
`p1`: Vector representing the vertices in the first partition.  
`p2`: Vector representing the vertices in the second partition.  
`Internal`: Reference to an unordered map where the Internal Edge Density values for each vertex will be stored.  
`External`: Reference to an unordered map where the External Edge Density values for each vertex will be stored.  
`D`: Reference to an unordered map where the Density difference values (EED - IED) for each vertex will be stored.  
1. For each vertex in partition 1 (`p1`), iterate through its adjacent vertices (`F`).  
2. For each adjacent vertex, check if it belongs to partition 1 or partition 2:  
      If it belongs to partition 1, increment the Internal Edge Density (i) by the edge weight.  
      If it belongs to partition 2, increment the External Edge Density (e) by the edge weight.  
3. Store the `Internal` (i) and `External` (e) Edge Density values for the vertex in the respective unordered maps.

Repeat steps 1-3 for vertices in partition 2 (`p2`).  

Calculate the Density difference (EED - IED) for each vertex and store it in the unordered map `D`.  



## `calculateGain`

The `calculateGain` function computes the gain for each possible movement of vertices between two partitions in a graph. The gain represents the change in the density difference (EED - IED) if a vertex is moved from one partition to another. This gain is calculated by considering the change in density difference for all possible vertex movements between the two partitions. Parameters:  
`g`: Reference to the graph object on which calculations are performed.  
`p1`: Vector representing the vertices in the first partition.  
`p2`: Vector representing the vertices in the second partition.  
`D`: Reference to an unordered map containing the density difference values (EED - IED) for each vertex.  
`gain`: Reference to an unordered map where the gain for each possible movement of vertices between partitions will be stored. The key is a pair of vertices (one from each partition), and the value is the gain associated with moving these vertices.  
Iterate through each vertex in partition 1 (`p1`).  
For each vertex in partition 1, iterate through each vertex in partition 2 (`p2`).  
Calculate the gain for moving the current pair of vertices from different partitions.  
`Gain` is computed as the sum of the density differences of the vertices in their current partitions minus twice the edge weight between them.  
Store the gain value for each pair of vertices in the unordered map `gain`.  

## `calculateCutSize`

The `calculateCutSize` function computes the cut size of a partition in a graph. The cut size represents the total weight of edges that connect vertices in the partition to vertices outside the partition. Parameters:  
`p1`: Vector representing the vertices in the partition for which the cut size is calculated.  
`External`: Reference to an unordered map containing the External Edge Density values for each vertex. This map represents the sum of edge weights between vertices in the partition and vertices outside the partition.  

Return Value:  
+  `t`: Integer representing the cut size of the partition.


## `fiducciaMattheyses`

The fiducciaMattheyses function implements the Fiduccia-Mattheyses algorithm for graph partitioning. This algorithm recursively divides a graph into smaller subgraphs by iteratively moving vertices between partitions to minimize the cut size. The cut size represents the total weight of edges that connect vertices in different partitions. Parameters:  
`g`: Reference to the graph object on which partitioning is performed.  
`np`: Integer representing the desired number of partitions.  
Initialize partitions by evenly distributing vertices into two partitions.  
Calculate the Internal and External Edge Densities for each vertex in the partitions.  
Calculate the initial cut size of the partitions.  
Repeat until no further improvement can be made:  
  a. Calculate the gain for moving each pair of vertices between partitions.  
  b. Identify the pair of vertices with the maximum gain.  
  c. Move the identified pair of vertices between partitions, ensuring that the maximum weight constraints are met.  
  d. Recalculate the Internal and External Edge Densities and the cut size of the partitions.  
  e. If the cut size decreases, update the partitions.  
  
Recursively apply the Fiduccia-Mattheyses algorithm to each subgraph until the desired number of partitions is reached.  

   
## `isPowerOf2`

This function has one input and gets the `np` as the number of partitions then checks whether it is a multiple of a power of 2 or not.

## `DFS`

The DFS function is a recursive function that performs depth-first search traversal starting from a given vertex in the graph. This function has three parameters and is used in the function of `isContiguous` to check that the graph is contiguous or not:

1. `graph`: This parameter represents the adjacency matrix of the graph. It's a 2D vector where graph[i][j] is 1 if there is an edge from vertex i to vertex j, and 0 otherwise.
2. `visited`: This parameter is a reference to a boolean vector indicating whether each vertex has been visited during the DFS traversal. Initially, all elements of this vector are set to false to indicate that no vertices have been visited.
3. `vertex`: This parameter represents the current vertex being visited during the DFS traversal. Initially, this will be the starting vertex of the traversal.

## `isContiguous`

This function gets the `graph` as an input and then uses depth-first search (DFS) algorithms to traverse the graph and check if all vertices are reachable from any arbitrary starting vertex. If all vertices are reachable, then the graph is contiguous and returns `true` otherwise it returns `false`.

## `print`

This function receives the grap `g` as an input and prints it in the output.

## `print_partitions`

After splitting the graph in each iteration we will have two partitions `result`, so we pass them to this function and it prints them in the output.
